---
title: "Banded Dotterel Moult Study"
subtitle: | 
  Exploration of dataset
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: 
 - name: Luke Eberhart-Hertel
   orcid: 0000-0001-7311-6088
   email: luke.eberhart@bi.mpg.de
   url: https://www.bi.mpg.de/person/115852/2867
   affiliations:
     - ref: bk
 - name: Bashar Jarayseh
   affiliations:
     - ref: bk
 - name: Ailsa Howard
   affiliations:
     - ref: ah
 - name: Emma Williams
   affiliations:
     - ref: ew
 - name: Colin O`Donnell
   affiliations:
     - ref: ew
 - name: Bart Kempenaers
   affiliations:
     - ref: bk
affiliations:
 - id: bk
   number: 1
   name: Department of Ornithology, Max Planck Institute for Biological Intelligence, Seewiesen, Germany
 - id: ah
   number: 2
   name: South Bay Banded Dotterel Project, Kaikoura, New Zealand
 - id: ew
   number: 3
   name: Department of Conservation, Christchurch, New Zealand
format: 
  html:
    toc: true
    code-fold: true
    code-tools: true
    self-contained: true
    highlight-style: github
    theme: Cosmo
execute:
  warning: false
  cache: true
editor_options: 
  chunk_output_type: console
---
```{r}
knitr::opts_chunk$set(cache = TRUE)
```

## Prerequisites

### R packages

-   The following packages are needed for analysis and can be easily installed from [CRAN](http://cran.r-project.org/) or GitHub by running the following code chunk:

```{r, message=FALSE, results='hide', warning=FALSE, results='hide', cache=FALSE}
# a vector of all the packages needed in the project
packages_required_in_project <- c("tidyverse",
                                  "readxl",
                                  "RMark",
                                  "RColorBrewer",
                                  "patchwork",
                                  "mapview",
                                  "lubridate",
                                  "extrafont",
                                  "here",
                                  "DT",
                                  "leaflet",
                                  "sf",
                                  "leafpop",
                                  "tsibble",
                                  "corrplot",
                                  "gghalves",
                                  "gam",
                                  "pscl",
                                  "gamlss",
                                  "gt",
                                  "lme4",
                                  "ggpattern",
                                  "gtsummary",
                                  "effects",
                                  "lattice")
                                  
# of the required packages, check if some need to be installed
new.packages <- 
  packages_required_in_project[!(packages_required_in_project %in% 
                                   installed.packages()[,"Package"])]

# install all packages that are not locally available
if(length(new.packages)) install.packages(new.packages)

# load all the packages into the current R session
lapply(packages_required_in_project, require, character.only = TRUE)

# set the home directory to where the project is locally based (i.e., to find 
# the relevant datasets to import, etc.
here::set_here()
```

### Plotting themes

-   The following plotting themes, colors, and typefaces are used throughout the project:

```{r, message=FALSE, results='hide', warning=FALSE}
# Find fonts from computer that you want. Use regular expressions to do this
# For example, load all fonts that are 'verdana' or 'Verdana'
extrafont::font_import(pattern = "[V/v]erdana", prompt = FALSE) 

# check which fonts were loaded
extrafont::fonts()
extrafont::fonttable()
extrafont::loadfonts() # load these into R

# define the plotting theme to be used in subsequent ggplots
luke_theme <- 
  theme_bw() +
  theme(
    text = element_text(family = "Verdana"),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 8),
    axis.title.x = element_text(size = 10),
    axis.text.x  = element_text(size = 8), 
    axis.title.y = element_text(size = 10),
    axis.text.y = element_text(size = 8),
    strip.text = element_text(size = 10),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.ticks = element_line(linewidth = 0.5, colour = "grey40"),
    axis.ticks.length = unit(0.2, "cm"),
    panel.border = element_rect(linetype = "solid", colour = "grey"),
    legend.position.inside = c(0.1, 0.9)
  )
```

## Explore Bashar's Dataset (sent 12-Aug-2024)
This dataset contains the scored moult data for all usable photos from the 

```{r}
# import data with all columns as character (so that no auto-formatting is done by R)
dat <- 
  read.csv(here("D:/IRT/Dotterel molt - IRT2/R/data/Dataset21_24.csv"), colClasses = "character")

# check values of Date column for mistakes...looks good
unique(dat$Date)

# check values of Score column for mistakes...looks good
unique(dat$Score)

# check values of Rings_comb column for mistakes...looks good
unique(dat$Rings_comb)

# import sex information
dat_sexes <- 
  read.csv(here("data/bdot_sexes.csv"), colClasses = "character") %>% 
  rename(Rings_comb = Bands_comb) %>% 
  mutate(Rings_comb = str_sub(Rings_comb, 1, 4))

dat_sexes %>% pull(Rings_comb) %>% unique() %>% length()
nrow(dat_sexes)
dat_sexes[which(duplicated(dat_sexes)), ]

# mutate the Date column into a date variable
dat <- 
  dat %>% 
    mutate(date = paste(substring(Date, first = 7, last = 10), 
                        substring(Date, first = 4, last = 5),
                        substring(Date, first = 1, last = 2),
                       sep = "-") %>% as.Date()) %>% 
  # subset to data with Molt == 1
  filter(Molt == 1) %>% 
  # specify the season as the first calender year
  mutate(season = ifelse(month(date) < 7, year(date) - 1, year(date))) %>% 
  # change to Julian date shifted for the Southern Hemisphere (1 = July 1)
  mutate(date_J = as.numeric(format(date + 181, "%j"))) %>% 
  # join the sexes provided by Ailsa
  left_join(., dat_sexes, by = "Rings_comb") %>% 
  # remove individuals with unknown sex
  filter(sex != "U")

dat %>% 
  group_by(season) %>% 
  summarise(n_obs = n())

# summarize the number of individuals in the dataset...64 unique combos
dat %>%
  pull(Rings_comb) %>% unique() %>% length()

# summarise the number of seasons for each individual...47 have more than one season of data
dat %>%
  select(Rings_comb, season) %>% 
  distinct() %>% 
  group_by(Rings_comb) %>% 
  summarise(n_seasons = n()) %>% 
  arrange(desc(n_seasons)) %>% 
  filter(n_seasons > 1) %>%
  nrow()

# summarise the number of usable photos for each individual...
dat %>%
  group_by(Rings_comb, season) %>% 
  summarise(n_photos = n()) %>% 
  arrange(desc(n_photos))

# summarise the number of usable photos for each individual...
dat %>%
  group_by(Rings_comb, season) %>% 
  summarise(n_photos = n()) %>% 
  arrange(desc(n_photos))

# 2021-2022 season data
ggplot(data = dat %>% filter(season == 2021) %>% mutate(Score = as.numeric(Score))) +
  geom_point(aes(y = 1, x = date, fill = Score), 
             pch = 21, color = "black", size = 3) +
  facet_wrap(. ~ Rings_comb, ncol = 1, strip.position = "right") +
  scale_fill_gradient(high = "#cc4c02", low = "white") +
  theme_bw() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks = element_blank(),
        strip.text.y.right = element_text(angle = 0)) +
  scale_x_date(date_labels = "%W", expand = c(0.01, 0.01), 
               date_breaks = "3 week", 
               limits = c(as.Date("2021-07-05"), as.Date("2022-05-01"))) +
  xlab("week")

# 2022-2023 season data (not as good coverage as the previous season)
ggplot(data = dat %>% filter(season == 2022) %>% mutate(Score = as.numeric(Score))) +
  geom_point(aes(y = 1, x = date, fill = Score), 
             pch = 21, color = "black", size = 3) +
  facet_wrap(. ~ Rings_comb, ncol = 1, strip.position = "right") +
  scale_fill_gradient(high = "#cc4c02", low = "white") +
  theme_bw() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks = element_blank(),
        strip.text.y.right = element_text(angle = 0)) +
  scale_x_date(date_labels = "%W", expand = c(0.01, 0.01), 
               date_breaks = "3 week", 
               limits = c(as.Date("2022-07-05"), as.Date("2023-05-01"))) +
  xlab("week")



# 2023-2024 season data 
ggplot(data = dat %>% filter(season == 2023) %>% mutate(Score = as.numeric(Score))) +
  geom_point(aes(y = 1, x = date, fill = Score), 
             pch = 21, color = "black", size = 3) +
  facet_wrap(. ~ Rings_comb, ncol = 1, strip.position = "right") +
  scale_fill_gradient(high = "#cc4c02", low = "white") +
  theme_bw() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks = element_blank(),
        strip.text.y.right = element_text(angle = 0)) +
  scale_x_date(date_labels = "%W", expand = c(0.01, 0.01), 
               date_breaks = "3 week", 
               limits = c(as.Date("2023-07-05"), as.Date("2024-05-01"))) +
  xlab("week")

```

### sex-specific differences in breeding plumage

```{r}
# extract the core breeding months (i.e., when presumably all birds are at their maximum breeding plumage), and determine the maximum score for each individual. Note: only looking at 2021-2022 season as it has the most even coverage across the breeding season
ind_breeding_scores <- 
  dat %>% 
  #filter(season == 2021) %>%
  mutate(Score = as.numeric(Score)) %>% 
  mutate(breeding_season = ifelse(month(date) %in% c(8, 9, 10, 11), 1, 0)) %>% 
  filter(breeding_season == 1) %>% 
  group_by(season, Rings_comb, sex) %>% 
  summarise(max_breeding_score = max(Score))

# Assess sample sizes of each sex
ind_breeding_scores %>% 
  group_by(sex) %>% 
  summarise(n_distinct(Rings_comb))


#linear mixed model for the difference in max score between sexes
mod2 <- lmer(max_breeding_score ~  sex +
         (1 | Rings_comb) + (1|season) , 
              data = ind_breeding_scores)

summary(mod2)
plot(allEffects(mod2))



# density plot of sex-specific breeding plumage score distributions
ggplot() +
  geom_density(data = ind_breeding_scores,
               aes(max_breeding_score, fill = sex), alpha = 0.5, adjust = 1) +
  luke_theme +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = c(0.15, 0.9)) +
  xlab("maximum individual breeding plumage score") +
  scale_colour_brewer(palette = "Dark2", direction = -1,
                      name = "Sex",
                      labels = c("Female (N = 29)", "Male (N = 21)")) +
  scale_fill_brewer(palette = "Dark2", direction = -1,
                    name = "Sex",
                    labels = c("Female (N = 29)", "Male (N = 21)"))
```

### within-individual moult dynamics
```{r}
# calcualte the individual proportional moult scores by comparing each score to a given individual's max (determined in previous chunk). Note: only looking at 2021-2022 season at this stage due to more even coverage of Ailsa's photos across the season.
ind_prop_molt_scores <- 
  dat %>% 
  #filter(season == 2021) %>% 
  mutate(Score = as.numeric(Score)) %>% 
  left_join(., select(ind_breeding_scores, -sex), by = c("Rings_comb","season")) %>% 
  filter(!is.na(max_breeding_score)) %>% 
  mutate(prop_molt_score = (Score-1)/(max_breeding_score-1))

# mixed effects binomial model comparing sex and date effect on the changes in moult scores
mod1 <- 
  lme4::glmer(prop_molt_score ~ 
         date_J + sex +
         (1 | Rings_comb) + (1|season),
       data = ind_prop_molt_scores, 
       family = binomial,
       control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e+06)))

# strong date effect, but no sex effect
tbl_regression(mod1, intercept = TRUE, 
               label = list(date_J ~ "Date", sex ~ "Sex"))

# extract predicted trends
pr <- ggeffects::predict_response(mod1, c("date_J [30:293]", "sex"))

# back-transform the dates (i.e., Julian dates were optimized for Austral summer)
### How can I apply this code to all seasons?
dates_for_plot <- 
  data.frame(date = as.Date((filter(dat, season == 2021) %>% 
                               pull(date) %>% min()):
                              (filter(dat, season == 2021) %>% 
                                 pull(date) %>% max())),
             date_J = (filter(dat, season == 2021) %>% 
                         pull(date_J) %>% min()):
               (filter(dat, season == 2021) %>% 
                  pull(date_J) %>% max()))

# join the back-transformed dates to model fits
mod1_fits <- 
  as.data.frame(pr) %>% 
  rename(date_J = x,
         sex = group) %>% 
  left_join(., dates_for_plot, by = "date_J")

# plot the model
ggplot() +
  geom_line(data = mod1_fits, 
            aes(x = date, y = predicted, color = sex)) +
  geom_ribbon(data = mod1_fits, 
              aes(x = date, ymax = conf.high, ymin = conf.low, fill = sex),
              lwd = 1, alpha = 0.25) +
  luke_theme +
  theme(legend.position = c(0.3, 0.2),
        legend.justification = c(1, 0),
        strip.background = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, 
                                   angle = 45, 
                                   hjust = 1, 
                                   vjust = 1)) +
  ylab("proportion of breeding plumage") +
  scale_x_date(date_labels = "%B", 
               expand = c(0.01, 0.01), 
               date_breaks = "1 month") +
  scale_colour_brewer(palette = "Dark2", direction = -1,
                      name = "Sex",
                      labels = c("Female (N = 29)", "Male (N = 21)")) +
  scale_fill_brewer(palette = "Dark2", direction = -1,
                    name = "Sex",
                    labels = c("Female (N = 29)", "Male (N = 21)"))
```
